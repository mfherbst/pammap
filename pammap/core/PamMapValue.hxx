//
// Copyright (C) 2018 by Michael F. Herbst and contributors
//
// This file is part of pammap.
//
// pammap is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published
// by the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// pammap is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with pammap. If not, see <http://www.gnu.org/licenses/>.
//

//
// Do not edit. This file has been automatically generated by the script
// PamMapValue.hxx.generate.py
// Instead edit the script and rerun it.
//
#pragma once
#include "ArrayView.hpp"
#include "IsSupportedType.hxx"
#include "any.hpp"
#include "typedefs.hxx"

namespace pammap {

/** \brief Class to contain an entry value in a PamMap.
    Essentially a slightly specialised pammap::any */
class PamMapValue : public any {
 public:
  PamMapValue() = default;

  /** Catch-all constructor, which defaults to an error */
  template <typename ValueType>
  PamMapValue(ValueType) : PamMapValue() {
    static_assert(!std::is_unsigned<ValueType>::value,
                  "Unsigned integer types are not supported with PamMap. "
                  "Use a signed type instead.");

    static_assert(IsSupportedType<ValueType>::value,
                  "This value type is not supported by PamMap.");
  }

  /** Construction from Integer */
  PamMapValue(Integer val) : any(std::move(val)) {}

  /** Construction from Float */
  PamMapValue(Float val) : any(std::move(val)) {}

  /** Construction from Complex */
  PamMapValue(Complex val) : any(std::move(val)) {}

  /** Construction from String */
  PamMapValue(String val) : any(std::move(val)) {}

  /** Construction from ArrayView<Integer> */
  PamMapValue(ArrayView<Integer> val) : any(std::move(val)) {}

  /** Construction from ArrayView<Float> */
  PamMapValue(ArrayView<Float> val) : any(std::move(val)) {}

  /** Construction from ArrayView<Complex> */
  PamMapValue(ArrayView<Complex> val) : any(std::move(val)) {}

  /** Construction from ArrayView<String> */
  PamMapValue(ArrayView<String> val) : any(std::move(val)) {}

  //
  // The int type gets special treatment because it is the default for raw numbers
  //
  /** \brief Make an PamMapValue out of an int. Behaves like a PamMapValue
    *        containing an INTEGER type */
  PamMapValue(int i) : PamMapValue(static_cast<Integer>(i)) {}

  //
  // Same for const char*
  //
  /** \brief Make an PamMapValue out of a const char*.
    * This behaves like the equivalent GenMapValue of a  std::string */
  PamMapValue(const char* s) : PamMapValue(std::string(s)) {}

  /** Return the demangled typename of the type of the internal object. */
  std::string type_name() const;
};

} // namespace pammap
