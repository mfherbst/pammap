//
// Copyright (C) 2018 by Michael F. Herbst and contributors
//
// This file is part of pammap.
//
// pammap is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published
// by the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// pammap is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with pammap. If not, see <http://www.gnu.org/licenses/>.
//

//
// Do not edit. This file has been automatically generated by the script
// generate_dtype_code.py
// Instead edit the script and rerun it.
//
#pragma once
#include "DataBlock.hpp"
#include "IsSupportedType.hxx"
#include "any.hpp"
#include "typedefs.hxx"

namespace pammap {

/** \brief Class to contain an entry value in a PamMap.
    Essentially a slightly specialised pammap::any */
class PamMapValue : public any {
 public:
  PamMapValue() = default;

  /** Catch-all constructor, which defaults to an error */
  template <typename ValueType>
  PamMapValue(ValueType) : PamMapValue() {
    static_assert(!std::is_unsigned<ValueType>::value,
                  "Unsigned integer types are not supported with PamMap. "
                  "Use a signed type instead.");

    static_assert(IsSupportedType<ValueType>::value,
                  "This value type is not supported by PamMap.");
  }

  /** Catch-all constructor for std::vector */
  template <typename ValueType>
  PamMapValue(std::vector<ValueType>) : PamMapValue() {
    static_assert(IsSupportedType<ValueType>::value,
                  "Cannot assign a list/array of values as a std::vector "
                  "with PamMap. Use the low-level DataBlock<T> for this purpose.");
  }

  /** Construction from Integer */
  PamMapValue(Integer val) : any(std::move(val)) {}

  /** Construction from Float */
  PamMapValue(Float val) : any(std::move(val)) {}

  /** Construction from Complex */
  PamMapValue(Complex val) : any(std::move(val)) {}

  /** Construction from String */
  PamMapValue(String val) : any(std::move(val)) {}

  /** Construction from DataBlock<Integer> */
  PamMapValue(DataBlock<Integer> val) : any(std::move(val)) {}

  /** Construction from DataBlock<Float> */
  PamMapValue(DataBlock<Float> val) : any(std::move(val)) {}

  /** Construction from DataBlock<Complex> */
  PamMapValue(DataBlock<Complex> val) : any(std::move(val)) {}

  /** Construction from DataBlock<String> */
  PamMapValue(DataBlock<String> val) : any(std::move(val)) {}

  /** \brief Make a PamMapValue out of an initialiser list by conversion to
             a DataBlock of the appropriate type. */
  template <typename T>
  PamMapValue(const std::initializer_list<T> il) : PamMapValue(DataBlock(il)) {
    static_assert(IsSupportedType<DataBlock<T>>::value,
                  "The chosen type is not supported for list elements with PamMap.");
  }

  //
  // The int type gets special treatment because it is the default for raw
  // numbers, such that simple things like PamMapValue{1,2,3} just work.
  //
  /** \brief Make an PamMapValue out of an int. Behaves like a PamMapValue
    *        containing an INTEGER type */
  PamMapValue(int i) : PamMapValue(static_cast<Integer>(i)) {}

  /** \brief Make a PamMapValue out of an initialiser list of int */
  PamMapValue(std::initializer_list<int> il)
        : PamMapValue(DataBlock<Integer>(il.begin(), il.end())) {}

  //
  // Same for const char*
  //
  /** \brief Make an PamMapValue out of a const char*.
    * This behaves like the equivalent GenMapValue of a  std::string */
  PamMapValue(const char* s) : PamMapValue(std::string(s)) {}

  /** Return the demangled typename of the type of the internal object. */
  std::string type_name() const;
};

} // namespace pammap
