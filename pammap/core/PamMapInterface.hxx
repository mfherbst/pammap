//
// Copyright (C) 2018 by Michael F. Herbst and contributors
//
// This file is part of pammap.
//
// pammap is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published
// by the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// pammap is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with pammap. If not, see <http://www.gnu.org/licenses/>.
//

//
// Do not edit. This file has been automatically generated by the script
// generate_dtype_code.py
// Instead edit the script and rerun it.
//
#pragma once
#ifdef SWIG
#include "typedefs.hxx"
%apply (pammap::DataBlock<pammap::Complex> DATAVIEW) {(pammap::DataBlock<pammap::Complex> view)}
%apply (pammap::DataBlock<pammap::Integer> DATAVIEW) {(pammap::DataBlock<pammap::Integer> view)}
%apply (pammap::DataBlock<pammap::Float> DATAVIEW) {(pammap::DataBlock<pammap::Float> view)}
#else
#include "PamMap.hpp"
#endif

namespace pammap {

struct PamMapInterface : public PamMap {
void update_complex(std::string key, Complex value) {
  this->update(key, std::move(value));
}

Complex get_complex(std::string key) {
  return this->at<Complex>(key);
}

void update_integer(std::string key, Integer value) {
  this->update(key, std::move(value));
}

Integer get_integer(std::string key) {
  return this->at<Integer>(key);
}

void update_float(std::string key, Float value) {
  this->update(key, std::move(value));
}

Float get_float(std::string key) {
  return this->at<Float>(key);
}

void update_string(std::string key, String value) {
  this->update(key, std::move(value));
}

String get_string(std::string key) {
  return this->at<String>(key);
}

/** Update the value of the PamMap behind the given key,
  * placing a view to the passed DataBlock<Complex> data inside it.
  * The passed object and the stored object point to the same memory.
  * The caller needs to make sure that the memory is not deallocated
  * as long as it could be in use by the PamMap. */
void update_datablock_complex_view(std::string key, pammap::DataBlock<pammap::Complex> view) {
  this->update(key, std::move(view));
}

/** Update the value of the PamMap behind the given key,
  * placing a copy of the passed DataBlock<Complex> value inside it.
  * The passed object and the stored object point to independent data
  * after the call */
void update_datablock_complex_copy(std::string key, pammap::DataBlock<pammap::Complex> view) {
  // Make a copy of the view including the memory
  DataBlock<Complex> copy(view, Memory::OwnCopy);
  this->update(key, std::move(copy));
}

pammap::DataBlock<pammap::Complex> get_datablock_complex(std::string key) {
  return this->at<DataBlock<Complex>>(key);}

/** Update the value of the PamMap behind the given key,
  * placing a view to the passed DataBlock<Integer> data inside it.
  * The passed object and the stored object point to the same memory.
  * The caller needs to make sure that the memory is not deallocated
  * as long as it could be in use by the PamMap. */
void update_datablock_integer_view(std::string key, pammap::DataBlock<pammap::Integer> view) {
  this->update(key, std::move(view));
}

/** Update the value of the PamMap behind the given key,
  * placing a copy of the passed DataBlock<Integer> value inside it.
  * The passed object and the stored object point to independent data
  * after the call */
void update_datablock_integer_copy(std::string key, pammap::DataBlock<pammap::Integer> view) {
  // Make a copy of the view including the memory
  DataBlock<Integer> copy(view, Memory::OwnCopy);
  this->update(key, std::move(copy));
}

pammap::DataBlock<pammap::Integer> get_datablock_integer(std::string key) {
  return this->at<DataBlock<Integer>>(key);}

/** Update the value of the PamMap behind the given key,
  * placing a view to the passed DataBlock<Float> data inside it.
  * The passed object and the stored object point to the same memory.
  * The caller needs to make sure that the memory is not deallocated
  * as long as it could be in use by the PamMap. */
void update_datablock_float_view(std::string key, pammap::DataBlock<pammap::Float> view) {
  this->update(key, std::move(view));
}

/** Update the value of the PamMap behind the given key,
  * placing a copy of the passed DataBlock<Float> value inside it.
  * The passed object and the stored object point to independent data
  * after the call */
void update_datablock_float_copy(std::string key, pammap::DataBlock<pammap::Float> view) {
  // Make a copy of the view including the memory
  DataBlock<Float> copy(view, Memory::OwnCopy);
  this->update(key, std::move(copy));
}

pammap::DataBlock<pammap::Float> get_datablock_float(std::string key) {
  return this->at<DataBlock<Float>>(key);}

};

} // namespace pammap
