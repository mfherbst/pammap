#!/usr/bin/env python3
## vi: tabstop=4 shiftwidth=4 softtabstop=4 expandtab
## ---------------------------------------------------------------------
##
## Copyright (C) 2018 by Michael F. Herbst and contributors
##
## This file is part of pammap.
##
## pammap is free software: you can redistribute it and/or modify
## it under the terms of the GNU Lesser General Public License as published
## by the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## pammap is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU Lesser General Public License for more details.
##
## You should have received a copy of the GNU Lesser General Public License
## along with pammap. If not, see <http://www.gnu.org/licenses/>.
##
## ---------------------------------------------------------------------

from datetime import date
import os
import sys
import constants


def licence_header_cpp():
    ret = """//
    // Copyright (C) {0:} by Michael F. Herbst and contributors
    //
    // This file is part of pammap.
    //
    // pammap is free software: you can redistribute it and/or modify
    // it under the terms of the GNU Lesser General Public License as published
    // by the Free Software Foundation, either version 3 of the License, or
    // (at your option) any later version.
    //
    // pammap is distributed in the hope that it will be useful,
    // but WITHOUT ANY WARRANTY; without even the implied warranty of
    // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    // GNU Lesser General Public License for more details.
    //
    // You should have received a copy of the GNU Lesser General Public License
    // along with pammap. If not, see <http://www.gnu.org/licenses/>.
    //

    //
    // Do not edit. This file has been automatically generated by the script
    // {1:}
    // Instead edit the script and rerun it.
    //
    """.format(date.today().year, os.path.basename(__file__))
    return [s.strip() for s in ret.split("\n")]


NAMESPACE_OPEN = [
    "",
    "namespace pammap {",
    "",
]


NAMESPACE_CLOSE = [
    "",
    "} // namespace pammap",
    "",
]


def to_cpp_type(dtype):
    """Convert the dtype to the C++ name used for it"""
    return dtype[0].upper() + dtype[1:]


def generate_typedefs(dtypes):
    """
    Generate the typedefs, which map the C++ names
    for the types to the underlying C++ types.
    """

    output = licence_header_cpp()
    for hdr in constants.cpp.headers:
        output.append("#include " + hdr)

    output += [
        "",
        "// Typedefs mapping the dtype names to their underlying C++ types",
        ""
    ]

    output += NAMESPACE_OPEN
    for dtype in dtypes:
        underlying_type = constants.cpp.underlying_type[dtype]
        output += ["typedef " + underlying_type + " " + to_cpp_type(dtype) + ";"]
    output += NAMESPACE_CLOSE
    return "\n".join(output)


def generate_data_block_instantiation(dtypes):
    output = licence_header_cpp()
    output += ["#include \"typedefs.hxx\""]

    output += NAMESPACE_OPEN
    for dtype in dtypes:
        output.append("template class DataBlock<{0:}>;".format(to_cpp_type(dtype)))
    output += NAMESPACE_CLOSE

    return "\n".join(output)


def generate_is_supported_type(dtypes):
    # TODO Instead of this, explicitly generate
    #      the code making an EntryValue object.

    output = licence_header_cpp()
    output += ["#include <type_traits>"]
    output += ["#include \"typedefs.hxx\""]

    output += NAMESPACE_OPEN
    output += [
        "/** Is the type T supported by pammap for storage. */",
        "template<typename T>",
        "struct IsSupportedType : public std::false_type {};",
        "",
    ]

    supported_types = [to_cpp_type(dtype) for dtype in constants.cpp.underlying_type]
    supported_types += [
        "DataBlock<" + cpptype + ">" for cpptype in supported_types
    ]
    for cpptype in supported_types:
        output += [
            "/** Specialisation of IsSupportedType<T> for " + cpptype + ".*/",
            "template<>",
            "struct IsSupportedType<" + cpptype + "> : public std::true_type {};",
            "",
        ]

    output += NAMESPACE_CLOSE
    return "\n".join(output)


def generate_pammap_interface(dtypes):
    output = licence_header_cpp()
    output += [
        "#pragma once",
        "#ifndef SWIG",
        "#include \"PamMap.hpp\"",
        "#endif",
    ]
    output += NAMESPACE_OPEN
    output += ["struct PamMapInterface : public PamMap {"]

    for dtype in dtypes:
        if dtype != "integer": continue
        cpptype = to_cpp_type(dtype)

        # Dump the function definition to update an internal value
        output += [
            "void update_" + dtype + "(std::string key, " + cpptype + " value) {",
            "  this->update(key, value);",
            "}"
        ]

        # Dump the function definition to retrieve a value
        output += [
            cpptype + " get_" + dtype + "(std::string key) {",
            "  return this->at<" + cpptype + ">(key);",
            "}"
        ]

    output += ["};"]
    output += NAMESPACE_CLOSE
    return "\n".join(output)


def main():
    if "-h" in sys.argv or "--help" in sys.argv:
        print("Generate type-specific cxx and hxx files of the project.")
        raise SystemExit()

    with open("typedefs.hxx", "w") as f:
        f.write(generate_typedefs(constants.DTYPES))

    with open("IsSupportedType.hxx", "w") as f:
        f.write(generate_is_supported_type(constants.DTYPES))

    with open("DataBlock.instantiation.hxx", "w") as f:
        f.write(generate_data_block_instantiation(constants.DTYPES))

    with open("PamMapInterface.hxx", "w") as f:
        f.write(generate_pammap_interface(constants.DTYPES))

if __name__ == "__main__":
    main()
